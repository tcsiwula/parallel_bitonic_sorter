/*==============================================================================
 Author:       =        Tim Siwula <tcsiwula@usfca.edu>
 Liscense:     =        GPLv2
 File:         =        mpi_bitonic.c
 Version:      =        0.01
 Created:      =        11/06/2015
 ==============================================================================
 Purpose:      =        Implement parallel MPI bitonic sort of a list that is
               =        either user input or generated by the program using a
               =        random number generator.
 ==============================================================================
 Compile:      =        mpicc -g -Wall -o mpi_bitonic mpi_bitonic.c
 ==============================================================================
 Debug:        =        mpicc -DDEBUG -g -Wall -o mpi_bitonic mpi_bitonic.c
 ==============================================================================
 Run:          =        mpiexec -n <p> <n> <'i'|'g'> ./mpi_bitonic
               =        i.e.    mpiexec -n 2 ./mpi_bitonic 8 g
               =        1.p: The number of processes, p, should evenly divide n
               =        2.n:   number of elements in the list (a power of 2).
               =        3.'i': user will enter list (no quotes).
               =        4.'g': program should generate list (no quotes).
 ==============================================================================
 Input:        =        If command line option 'i' is used,
               =        an n-element list of ints
 ==============================================================================
 Output:       =        The unsorted list and the sorted list.
 ==============================================================================
 Note:         =        1.  If the list is randomly generated, the keys are in
               =            the range 1 -- KEY_MAX.
               =         2.  The size of the list, n, should be a power of 2:
               =         the program doesn't check that this is the case.
 ............................................................................ */

/* ========================================================================== */
/*                          External libaries                                 */
/* ========================================================================== */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mpi.h>
/* .......................................................................... */

/* ========================================================================== */
/*                          Constants                                         */
/* ========================================================================== */
#define KEY_MAX 1000000
/* .......................................................................... */

/* ========================================================================== */
/*                          Custom function definitions                       */
/* ========================================================================== */
void Initialize_mpi(int argc, char* argv[], MPI_Comm* comm_p, int* p_p,
                    int* my_rank_p);
void Initializer(int* my_list[], int* neighbors_list[],
                 int* merge_list[], int list_size);
void Finalizer(int my_list[], int neighbors_list[],
               int merge_list[]);
void Get_args(int argc, char* argv[], int* n_p, char* ig_p,
              int* list_size, int number_of_processors);
void Read_list(char title[], int A[], int n);
void Debugger(int flag, int my_rank, int phase, int partner_size,
              int my_list[], int global_size, int list_size);
void Gen_list(int A[], int n);
void Mpi_Bitonic_sort(int my_rank, int p, int my_list[],
                      int neighbors_list[], int list_size,
                      MPI_Comm comm);
void Bitonic_sort_incr(int my_rank, int B[], int neighbors_list[],
                       int len, int p, MPI_Comm comm);
void Bitonic_sort_decr(int my_rank, int B[], int neighbors_list[],
                       int len, int p, MPI_Comm comm);
void Print_list_once(char* title, int A[], int n);
int  Reverse(int order);
void Scatter(char generate_list_flag, int my_list[], int neighbors_list[],
            int merge_list[], int global_list_size, int list_size, int my_rank,
                 MPI_Comm comm);
void Print_list(char* title, int my_list[], int list_size, int my_rank);
int Compare(const void* x_p, const void* y_p);
void Merge_split(int my_slope, int my_rank, int list_size, int my_list[],
                int neighbors_list[], int my_partner, MPI_Comm comm);
void Merge_split_high(int local_A[], int temp_B[], int local_n);
void Merge_split_low(int local_A[], int temp_B[], int local_n);
int log_base2(int partner_size);
void Gather(int my_list[], int global_list_size, int my_rank, int list_size);
/* .......................................................................... */

/* ========================================================================== */
/*                          Main( )                                           */
/* ========================================================================== */
int main(int argc, char* argv[])
{
    MPI_Comm comm;
    char generate_list_flag;
    int my_rank, global_list_size = 0, list_size = 0, p;
    int *my_list = NULL, *neighbors_list = NULL, *merge_list = NULL;
    Initialize_mpi(argc, argv, &comm, &p, &my_rank);
    Get_args(argc, argv, &global_list_size, &generate_list_flag, &list_size, p);

    Initializer(&my_list, &neighbors_list, &merge_list, list_size);

    Scatter(generate_list_flag, my_list, neighbors_list,
                merge_list, global_list_size, list_size, my_rank, comm);

    qsort(my_list, list_size, sizeof(int), Compare);

    Mpi_Bitonic_sort(my_rank, p, my_list, neighbors_list, list_size, comm);

    Finalizer(my_list, neighbors_list, merge_list);

    return 0;
}  /* main */
/* .......................................................................... */

/* ============================================================================
Function:     =        Initializer
Purpose:      =        Create heap memory for each processors list.
==============================================================================
Input arg:    =        1. my_list[]: A pointer to a given processors array.
              =        2. neighbors_list[]: A pointer to each processors array.
              =        3. merge_list[]: A pointer to a given processors array.
              =        4. list_size: The size of the processors array.
=========================================================================== */
void Initializer(int* my_list[], int* neighbors_list[], int* merge_list[],
                int list_size)
{
    // Allocate three lists for each processor, on the heap.
    *my_list = malloc(list_size*sizeof(int));
    *neighbors_list = malloc(list_size*sizeof(int));
    *merge_list = malloc(list_size*sizeof(int));
}
/* .......................................................................... */

/* ============================================================================
Function:     =        Mpi_Bitonic_sort
Purpose:      =        The root itteration logic for the bitonic sequence sort.
==============================================================================
Input arg:  =        1. my_rank: The size of the processors array.
            =        2. p: The size of the input array.
            =        3. my_list[]: A pointer to an array.
            =        4. neighbors_list[]: A pointer to an array.
            =        5. list_size: The size of the processors array.
            =        6. comm: The mpi communicator channel.
=========================================================================== */
void Mpi_Bitonic_sort(int my_rank, int p, int my_list[], int neighbors_list[],
                      int list_size, MPI_Comm comm)
{
    int partner_size, phase = 1;
    unsigned and_bit;

    for(partner_size = 2, and_bit = 2; partner_size <= p;
        partner_size = partner_size * 2, and_bit = and_bit << 1)
    {
        if((my_rank & and_bit) == 0)
        {
            #ifdef DEBUG
                Debugger(1, my_rank, phase, partner_size, my_list, p*list_size,
                            list_size);
            #endif
            Bitonic_sort_incr(my_rank, my_list, neighbors_list, list_size,
                                partner_size, comm);
        }
        else
        {
            #ifdef DEBUG
            Debugger(2, my_rank, phase, partner_size, my_list, p*list_size,
                        list_size);
            #endif
            Bitonic_sort_decr(my_rank, my_list, neighbors_list, list_size,
                                partner_size, comm);
        }
        #ifdef DEBUG
        Debugger(3, my_rank, phase, partner_size, my_list, p*list_size,
                list_size);
        #endif
        phase++;
    }

    if(my_rank == 0) printf("The list is now sorted. \n");
    Gather(my_list, p*list_size, my_rank, list_size);
}
/* .......................................................................... */

 /* ============================================================================
 Function:     =        Mpi_Bitonic_sort
 Purpose:      =        Use bitonic sort to sort the keys in my_list into
               =        increasing order.
 ==============================================================================
 Input arg:  =        1. my_rank: The size of the processors array.
             =        2. my_list[]: A pointer to an array.
             =        3. neighbors_list[]: A pointer to an array.
             =        4. list_size: The size of the processors array.
             =        5. partner_size: The size of partner pairing.
             =        6. comm: The mpi communicator channel.
 ==============================================================================
 Note:       =         len is a power of 2
 =========================================================================== */
void Bitonic_sort_incr(int my_rank, int my_list[], int neighbors_list[],
                        int list_size, int partner_size, MPI_Comm comm)
{
    unsigned xor_bit;
    int partner, stage, stage_limit;

    stage_limit = log_base2(partner_size);
    xor_bit = 1 << (stage_limit - 1);

    for(stage = 0; stage < stage_limit; stage++)
    {
        partner = my_rank ^ xor_bit;

        if(my_rank < partner)
        {
            Merge_split(1, my_rank, list_size, my_list, neighbors_list,
                        partner, comm);
        }
        else
        {
            Merge_split(0, my_rank, list_size, my_list, neighbors_list,
                        partner, comm);
        }
        xor_bit = xor_bit >> 1;
    }
} /* Bitonic_sort_incr */
/* .......................................................................... */

/* ============================================================================
Function:     =        Bitonic_sort_decr
Purpose:      =        Use bitonic sort to sort the keys in my_list into
              =        decreasing order.
==============================================================================
Input arg:  =        1. my_rank: The size of the processors array.
            =        2. my_list[]: A pointer to an array.
            =        3. neighbors_list[]: A pointer to an array.
            =        4. list_size: The size of the processors array.
            =        5. partner_size: The size of partner pairing.
            =        6. comm: The mpi communicator channel.
==============================================================================
Note:       =         len is a power of 2
=========================================================================== */
void Bitonic_sort_decr(int my_rank, int my_list[], int neighbors_list[],
                        int list_size, int partner_size, MPI_Comm comm)
{
    unsigned xor_bit;
    int partner, stage, stage_limit;

    stage_limit = log_base2(partner_size);
    xor_bit = 1 << (stage_limit - 1);

    for(stage = 0; stage < stage_limit; stage++)
    {
        partner = my_rank ^ xor_bit;

        if(my_rank > partner)
        {
            Merge_split(1, my_rank, list_size, my_list, neighbors_list,
                        partner, comm);
        }
        else
        {
            Merge_split(0, my_rank, list_size, my_list, neighbors_list,
                        partner, comm);
        }
        xor_bit = xor_bit >> 1;
    }
} /* Bitonic_sort_decr */
/* .......................................................................... */

/* ============================================================================
Function:     =        Merge_split
Purpose:      =        The root itteration logic for the merge split sort.
==============================================================================
Input arg:  =        1. my_slope: The direction to sort the list.
            =        2. my_rank: The processors rank.
            =        3. list_size: The size of each processors array.
            =        4. my_list[]: A pointer to an array.
            =        5. neighbors_list[]: A pointer to an array.
            =        6. my_partner: The processor to sendrecv with.
            =        7. comm: The mpi communicator channel.
=========================================================================== */
void Merge_split(int my_slope, int my_rank, int list_size, int my_list[],
                    int neighbors_list[], int my_partner, MPI_Comm comm)
{
    MPI_Status status;

    MPI_Sendrecv(my_list, list_size, MPI_INT,
                 my_partner, 0, neighbors_list, list_size,
                 MPI_INT, my_partner, 0, comm, &status);

    if(my_slope == 0)
    {
        Merge_split_high(my_list, neighbors_list, list_size);
    }
    else
    {
        Merge_split_low(my_list, neighbors_list, list_size);
    }
}
/* .......................................................................... */

/* ============================================================================
Function:     =        Merge_split_high
Purpose:      =        Merge the smallest local_n elements in local_A and temp_B
              =        into temp_C.  Then copy temp_C back into local_A.
==============================================================================
Input arg:  =        1. local_A: A pointer to an array.
            =        2. temp_B[]: A pointer to an array.
            =        3. local_n: The size of each processors array.
=========================================================================== */
void Merge_split_high(int local_A[], int temp_B[], int local_n)
{
    int ai, bi, ci;
    int *temp_C = malloc(local_n*sizeof(int));

    ai = local_n-1;
    bi = local_n-1;
    ci = local_n-1;
    while (ci >= 0) {
        if (local_A[ai] >= temp_B[bi]) {
            temp_C[ci] = local_A[ai];
            ci--; ai--;
        } else {
            temp_C[ci] = temp_B[bi];
            ci--; bi--;
        }
    }

    memcpy(local_A, temp_C, local_n*sizeof(int));
}  /* Merge_split_low */
/* .......................................................................... */

/* ============================================================================
Function:     =        Merge_split_low
Purpose:      =        Merge the smallest local_n elements in local_A and temp_B
              =        into temp_C.  Then copy temp_C back into local_A.
==============================================================================
Input arg:  =        1. local_A: A pointer to an array.
            =        2. temp_B[]: A pointer to an array.
            =        3. local_n: The size of each processors array.
=========================================================================== */
void Merge_split_low(int local_A[], int temp_B[], int local_n)
{
    int ai, bi, ci;
    int *temp_C = malloc(local_n*sizeof(int));
    ai = 0;
    bi = 0;
    ci = 0;
    while (ci < local_n) {
        if (local_A[ai] <= temp_B[bi]) {
            temp_C[ci] = local_A[ai];
            ci++; ai++;
        } else {
            temp_C[ci] = temp_B[bi];
            ci++; bi++;
        }
    }

    memcpy(local_A, temp_C, local_n*sizeof(int));
}  /* Merge_split_low */
/* .......................................................................... */

/* ============================================================================
Function:     =        Debugger
Purpose:      =       Print out debug phase and element types at various stages.
==============================================================================
Input arg:  =        1. flag: Flag for stage for specified output.
            =        7. my_rank: The processors rank.
            =        3. phase: The current phase of the algorithim.
            =        4. partner_size: The size of the paring among processors.
            =        5. my_list: Local list for each processor.
            =        6. global_size: The size of the input array.
            =        7. list_size: The size of the processors array.
=========================================================================== */
void Debugger(int flag, int my_rank, int phase, int partner_size, int my_list[],
                int global_size, int list_size)
{
    if (flag == 1)
    {
        printf("Processor %d's #%d %d-element butterfly now executing. \n",
                my_rank, phase, partner_size);
        fflush(stdout);
    }
    else if (flag == 2)
    {
        printf("Processor %d's #%d %d-element butterfly now executing. \n",
                my_rank, phase, partner_size);
        fflush(stdout);
    }
    else
    {
        if(my_rank == 0)
        {
            printf(" \nStage %d completed. \n", phase);
        }
        Gather(my_list, global_size, my_rank, list_size);
        fflush(stdout);
    }
}
/* .......................................................................... */

/* ============================================================================
Function:     =        log_base2
Purpose:      =        Compute the log of a number.
==============================================================================
Input arg:  =        1. partner_size: number to take log of.
==============================================================================
Output arg: =        1. counter: the log of partner_size.
=========================================================================== */
int log_base2(int partner_size)
{
    int counter = 0;
    unsigned binary_representation;

    binary_representation = (unsigned) partner_size;

    while(binary_representation != 1)
    {
        binary_representation = binary_representation >> 1;
        counter++;
    }

    return counter;
}
/* .......................................................................... */

 /* ============================================================================
 Function:     =        Get_args
 Purpose:      =        Get the command line arguments.
 ==============================================================================
 Input arg:  =        1. argc: Flag for list creation type.
             =        2. *argv[]: A pointer to an array.
             =        5. list_size: The size of the processors array.
             =        6. number_of_processors: The size of the processors array.
 ==============================================================================
 Out args:   =        1. list_size_p: A pointer an integer.
             =        2. generate_list_p: pointer to an i or g for list type.
 =========================================================================== */
void Get_args(int argc, char* argv[], int* list_size_p, char* generate_list_p,
                int* list_size, int number_of_processors)
{
    if (argc != 3)
    {
        fprintf(stderr, "usage: %s <n> <'i'|'g'>\n", argv[0]);
        fprintf(stderr, "n = number of elements in the list (a power of 2)\n");
        fprintf(stderr, "'i':  user will enter list (no quotes)\n");
        fprintf(stderr, "'g':  program should generate list (no quotes)\n");
        exit(0);
    }

    *list_size_p = strtol(argv[1], NULL, 10);
    *generate_list_p = argv[2][0];
    *list_size = *list_size_p/number_of_processors;
}  /* Get_args */
/* .......................................................................... */

/* ============================================================================
Function:     =        Read_list
Purpose:      =        Read in a list of ints
==============================================================================
Input arg:  =        1. n: The size of the processors array.
==============================================================================
Out args:   =       1. A[]: A pointer to an array.
=========================================================================== */
void Read_list(char title[], int A[], int n) {
    int i;

    printf("%s\n", title);
    for (i = 0; i < n; i++)
        scanf("%d", &A[i]);

}  /* Read_list */
/* .......................................................................... */

/* ============================================================================
Function:     =  Gen_list
Purpose:      =  Use a random number generator to generate an n-element list.
==============================================================================
Input arg:  =        1. n: The size of the processors array.
==============================================================================
Out args:   =   1. A[]: A pointer to an array.
==============================================================================
Note:      Elements of the list are in the range 1 -- KEY_MAX
=========================================================================== */
void Gen_list(int A[], int n) {
    int i;

    srandom(1);
    for (i = 0; i < n; i++)
        A[i] = 1 + random() % KEY_MAX;
}  /* Gen_list */
/* .......................................................................... */

/* ============================================================================
Function:     =        Scatter
Purpose:      =        Generate list on process 0, then scatter to others.
==============================================================================
Input arg:  =        1. generate_list_flag: Flag for list creation type.
            =        2. my_list[]: A pointer to an array.
            =        3. neighbors_list[]: A pointer to an array.
            =        4. merge_list[]: A pointer to an array.
            =        5. global_list_size: The size of the input array.
            =        6. list_size: The size of the processors array.
            =        7. my_rank: The size of the processors array.
            =        8. comm: The mpi communicator channel.
=========================================================================== */
void Scatter(char generate_list_flag, int my_list[], int neighbors_list[],
                int merge_list[], int global_list_size, int list_size,
                int my_rank, MPI_Comm comm)
{
    int *input_list = malloc(global_list_size*sizeof(int));;

    if (my_rank == 0)
    {
        if (generate_list_flag == 'g')
        {
            printf("Generating the list... \n");
            Gen_list(input_list, global_list_size);
        }
        else
        {
            printf("Please read in matrix into process 0.\n");
            Read_list("Enter the list", input_list, global_list_size);
        }

        Print_list_once("Orginal list:", input_list, global_list_size);
    }

    MPI_Scatter(input_list, list_size, MPI_INT,
                my_list, list_size, MPI_INT, 0, comm);

    free(input_list);
}  /* Scatter */
/* .......................................................................... */

/* ============================================================================
 Function:     =        Finalizer
 Purpose:      =        Clean up mpi logic and free heap memory.
 ==============================================================================
 Input arg:    =        1. my_list[]: A pointer to a given processors array.
               =        2. neighbors_list[]: A pointer to each processors array.
               =        3. merge_list[]: A pointer to a given processors array.
 =========================================================================== */
void Finalizer(int my_list[], int neighbors_list[], int merge_list[])
{
    // Deallocate each processors three lists from the heap.
    free(my_list);
    free(neighbors_list);
    free(merge_list);

    // Clean up mpi.
    MPI_Finalize();
}
/* .......................................................................... */

/* ============================================================================
 Function:     =        Initialize_mpi
 Purpose:      =        Set up mpi logic.
 ==============================================================================
 Input arg:    =        1. argc: The number of args.
               =        2. *comm_p: A pointer to the mpi communicator.
               =        3. *p_p: A pointer to the number of processors.
               =        4. *my_rank_p: A pointer to the processors rank.
 =========================================================================== */
void Initialize_mpi(int argc, char* argv[], MPI_Comm* comm_p, int* p_p,
                    int* my_rank_p)
{
    MPI_Init(&argc, &argv);
    *comm_p = MPI_COMM_WORLD;
    MPI_Comm_size(*comm_p, p_p);
    MPI_Comm_rank(*comm_p, my_rank_p);
}
/* .......................................................................... */

/* ============================================================================
 Function:     =        Print_list_once
 Purpose:      =        Print out a given processors list.
 ==============================================================================
 Input arg:    =        1. *title:  Text to output about the list.
               =        2. my_list[]: A pointer to a given processors array.
               =        3. list_size: The size of the processors array.
 =========================================================================== */
void Print_list_once(char* title, int my_list[], int list_size)
{
    int i;

    printf("%s\n", title);
    for (i = 0; i < list_size; i++)
        printf("%d ", my_list[i]);
    printf("\n\n");
}  /* Print_list */
/* .......................................................................... */

/* ============================================================================
 Function:     =        Print_list
 Purpose:      =        Print out a given processors list.
 ==============================================================================
 Input arg:    =        1. *title:  Text to output about the list.
               =        2. my_list[]: A pointer to a given processors array.
               =        3. list_size: The size of the processors array.
               =        4. my_rank: The current processors rank.
 =========================================================================== */
void Print_list(char* title, int my_list[], int list_size, int my_rank)
{
    int i;
    printf("Processor %d's %s\n", my_rank, title);
    for (i = 0; i < list_size; i++)
        printf("%d ", my_list[i]);
    printf("\n\n");
}  /* Print_list */
/* .......................................................................... */

/* ============================================================================
 Function:     =        Gather
 Purpose:      =        Print out a given processors list.
 ==============================================================================
 Input arg:    =        1. my_list[]: A pointer to a given processors array.
               =        2. global_list_size: The sum of all processors list size
               =        3. my_rank: The current processors rank.
               =        4. list_size: The size of the processors array.
 =========================================================================== */
void Gather(int my_list[], int global_list_size, int my_rank, int list_size)
{
    int *global_list = malloc(global_list_size*sizeof(int));

    MPI_Gather(my_list, list_size, MPI_INT, global_list, list_size,
               MPI_INT, 0, MPI_COMM_WORLD);
    if (my_rank == 0)
    {
        Print_list_once("\nThe updated list is:", global_list, global_list_size);
        printf("\n");
        free(global_list);
    }
} /* Gather */
/* .......................................................................... */

/* ============================================================================
Function:     =        Compare
Purpose:      =        Compare two integers and determine which is larger.
==============================================================================
Input arguments:      =        x_p, y_p
==============================================================================
Return value: =        -1 if *x_p < *y_p
                     0 if *x_p == *y_p
                     1 otherwise
==============================================================================
Note:         For use by qsort library function
=========================================================================== */
int Compare(const void* x_p, const void* y_p)
{
    int x = *((int*)x_p);
    int y = *((int*)y_p);

    if (x < y)
        return -1;
    else if (x == y)
        return 0;
    else /* x > y */
        return 1;
}  /* Compare */
/* .......................................................................... */
